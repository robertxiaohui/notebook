# 考试题目

## 选择题

### 1.(往年卷)

```
一个进程映像是（C）


A. 由协处理器执行的一个程序
B. 一个独立的程序+数据集
C. PCB结构与程序和数据的组合
D. 一个独立的程序
```







### 2.(往年卷)

```

执行系统调用的过程包括如下主要操作：

①返回用户态 ②执行陷入（trap）指令

③传递系统调用参数 ④执行相应的服务程序

正确的执行顺序是(C)



A ②->③->①->④
B ②->④->③->①
C ③->②->④>①
D ③->④->②->①



```



### 3.

```
有两个优先级相同的并发程序P1和P2,它们的执行过程如下所示，假设，当前信号量s1=0,s2=0,当前的z=2,进程运行
结束后，x、y和z的值分别是(C)
进程P1      进程P2
...         ...
y:=1;       x:=1;
y:=y+2;     x:=x+1;
z:=y+1;     P(s1);
V(s1):      x:=x+y:
P(s2);      z:=x+z;
y:=z+y;     V(s2)
...         ...


A.5,9,9
B.5,9,4
C.5,12,9
D.5,12,4
```



### 4.

```

当定时器产生时钟中断后，由时钟中断服务程序更新的部分内容是(D)
I. 内核中时钟变量的值 
II. 当前进程占用 CPU 的时间 
III. 当前进程在时间片内的剩余执行时间
A 仅 I、II
B 仅 II、III
C 仅 I、III
D I、II、III
```





### 5.(往年卷)

```

某系统正在执行三个进程P1、P2和P3，各进程的计算(CPU)时间和I/O时间比例如下表所示。
进程 计算时间 I/O时间
P1   90%    10%
P2   50%    50%
P3   15%    85% 
为提高系统资源利用率，合理的进程优先级设置应为
A．P1＞P2＞P3
B．P3＞P2＞P1
C．P2＞P1=P3
D．P1＞P2=P3

正确答案
B


```





### 6.

```
在支持多线程的系统中，进程P创建的若干个线程不能共享的是(D)。

A．进程P的代码段
B．进程P中打开的文件
C．进程P的全局变量
D．进程P中某线程的栈指针

正确答案
D

答案解析
[解析] 本题目考查线程的特点。引入线程的系统中，一个进程中的各个线程可以共享其隶属进程的资源，包括一个进程的代码段、数据段及所拥有系统资源，如已打开的文件、I/O设备等。而为了保证线程的独立运行，每个线程都应该包含独立的堆栈和CPU寄存器状态，这些是不能共享的。因此应该选D。
```



### 7.

![image-20210320122317574](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210320122324.png)



### 8.

```
当一个进程因在互斥信号量mutex上执行V(mutex)操作而导致唤醒另一个进程时，则mutex的值为(D)。

A．大于0
B．小于0
C．大于等于0
D．小于等于0


```



### 9.

```
有两个并发进程P1、P2，其程序代码如下：
p1()            p2()
{               { 
x=1;              x=-3; 
y=2;              c=x*x;
z=x+y;             print c;
print z;        }
}
可能打印出z的值有（）可能打印出的c值有（）（其中x为P1、P2的共享变量）。

A．z=1，-3；c=-1，9
B．z=-1，3；c=1，9
C．z=-1，3，1；c=9
D．z=3；c=1，9

正确答案
B

答案解析
本题关键是输出语句A2、B2中读取的x的值不同，由于A1、B1执行有先后问题，使得在执行A2、B2前，x的可能取值有两个就是1、-3；这样输出z的值可能是1+2=3或者是(-3)+2=1；输出c的值可能是1×l=1或者是(-3)×(-3)=9。
```



### 10.(无题)





### 11.(往年卷)

```
8.某系统采用改进型CLOCK置换算法，页表项中字段A为访问位，M为修改位。A=O表示页最近没有被访问， A=1表示页最近被访问过，M=O 表示页没有被修改过，M=1表示页被修改过。按(A, M)所有可能的取值，将页分为四类：(0, 0)、(1, 0)、(O, 1)和(1, 1)，则该算法淘汰页的次序为(D). 
A.(O, 0), (1, 1), (O, 1), (1, 0)
B.(0, 0), (1, 0), (O, 1), (1, 1) 
C.(O, 0), (O, 1), (1, 1), (1, 0) 
D.(O, 0), (O, 1), (1, 0), (1, 1)  
参考答案：D
```



### 12.(往年卷)

```
UNIX 文件系统中，如果一个盘块的大小为 1KB,每个盘块占 4 个字节，若进程访问偏移为 263168字节处的数据，须经过几次间址？(B)
A．2 次 B.1 次
C．3 次 D.直接寻址
```

![image-20210317164548491](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210317164701.png)



### 13.

```
若一个用户进程通过read系统调用读取一个磁盘文件中的数据，则下列关于此过程的叙述中，正确的是(A)
Ⅰ．若该文件的数据不在内存，则该进程进入睡眠等待状态 
Ⅱ．请求read系统调用会导致CPU从用户态切换到核心态
Ⅲ．read系统调用的参数应包含文件的名称

A．仅Ⅰ、Ⅱ
B．仅Ⅰ、Ⅲ
C．仅Ⅱ、Ⅲ
D．Ⅰ、Ⅱ和Ⅲ

正确答案
A

答案解析
用户进程通过read系统调用读取一个磁盘文件中的数据，若该文件的数据不在内存，则该进程进入睡眠等待状态。请求read系统调用会导致CPU从用户态切换到核心态。
```



### 14.(往年卷)

```
UNIX 操作系统中，输入输出设备看做是（D ）。
A.普通文件B.目录文件C.索引文件D.特殊文件

```



### 15.(往年卷)

```
若用户进程访问内存时产生缺页，则下列选项中，操作系统可能执行的操作是(B)
Ⅰ．处理越界错 
Ⅱ．置换页 
Ⅲ．分配内存

A．仅Ⅰ、Ⅱ
B．仅Ⅱ、Ⅲ
C．仅Ⅰ、Ⅲ
D．Ⅰ、Ⅱ和Ⅲ

正确答案
B
```



### 16.

```
下列选项中，导致创建新进程的操作是(C)。
Ⅰ．用户登录成功 Ⅱ．设备分配 Ⅲ．启动程序执行

A．仅Ⅰ和Ⅱ
B．仅Ⅱ和Ⅲ
C．仅Ⅰ和Ⅲ
D．Ⅰ、Ⅱ、Ⅲ

正确答案
C

答案解析
设备分配可能引起进程状态的改变，不会创建新进程(对应的设备驱动进程一般处于阻塞状态)，而用户登录成功和启动程序执行都会创建新的进程。
```



### 17.

```
系统总是访问磁盘的某个磁道而不响应对其他磁道的访问请求，这种现象称为磁背黏着。下列磁盘调度算法中，不会导致磁背黏着的是（A）
A.先来先服务(FCFS)
B.最短寻道时间优先(SSTF)
C.扫描算法(SCAN)
D.循环扫描算法 (CSCAN)

答案A
```







### 18.(无题)









### 19.

```
在一个多道系统中，就绪的进程数目越多，处理器的效率(C)。

A．越高
B．越低
C．不变
D．不确定

```



### 20.

```
FAT32的文件目录项不包括（C）。

A．文件名

B．文件访问权限说明

C．文件控制块的物理位置

D．文件所在的物理位置
```







## 名词解释(4题 20分)

```
1. 什么是进程？操作系统中为什么要引入进程？
进程是具有独立功能的程序在某一数据集上的一次运行活动
1.刻画进程的并发性，程序是指令和数据的集合，是静态的概念，无法描述在内存中动态运行的过程，引入进程刻画程序的并发执行
2.解决资源的共享性，程序无法描述可再入程序的共享性

2. 简要阐述虚拟存储器的三个主要特征？
1. 多次性  在进程运行前不需要全部装入内存，允许在运行时多次装入
2. 对换性   在进程运行时无需一直常驻内存，而是允许在进程运行过程中，将进程的页面换入、换出。
3. 虚拟性 在逻辑上扩充了内存


3. linux磁盘分成了三种柱面 磁道 扇区他们的名称和功能


4. 有交往的并发进程执行时出现与时间有关的错误  进程与时间有关的错误引发原因及重要举例
什么是与时间有关的错误？试举例说明。

引发原因：由于一个进程的执行速度通常无法为另一个进程所知，对于共享公共变量（资源）的并发进程来说，计算结果往往取决于这一组并发进程执行的相对速度。,速度是时间的函数,所以如果发生这种错误便称为与时间有关的错误，

所谓的的执行相对速度，其实就是指并发进程中每条指令的执行次序

举例:一种形式是结果不唯一，如飞机票售票问题。另一种是永远等待，如内存资源管理问题。


```











## 程序计算题 （4题 40分）

### 1.

![image-20210113113221499](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113113949.png)



```
题目：
1.请画出开始运行后的甘特图

2.结合甘特图说明时刻40,60,100,160作业A,B,C占用和释放CPU及外设资源的情况

3.最早结束的作业是哪个

4.最后结束的作业是哪个

5.计算这段时间CPU利用率(三个作业全部结束为止)
```



![image-20210113121108181](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113121737.png)





![image-20210113121114255](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113121742.png)



### 2.(往年卷)

![image-20210218194047642](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210218194054.png)

```
(1)Need矩阵如下图
   A B C D
P0 0 0 0 0
P1 0 7 5 0
P2 1 0 0 2
P3 0 6 4 2
(2)此该的安全性
Work Need Allocation W+A Finish
   A B C D A B C D A B C D A B C D
P0 1 5 2 0 0 0 0 0 0 0 1 2 1 5 3 2 True
P2 1 5 3 2 1 0 0 2 1 3 5 4 2 8 8 6 True
P1 2 8 8 6 0 7 5 O 1 0 0 0 3 8 8 6 True
P3 3 8 8 6 0 6 5 6 0 0 1 4 3 8 9 10 True
因为找到一个安全序列{PO，P2，P1，P3}，故当前系统处于安全状态。
(3)P1发出请求(0，4，2，0)
①进行两个判断：(0，4，2，0)小于P1的Need(0，7，5，0)；
(0，4，2，0)小于当前的剩余Available(1，5，2，0)
②假定分配给P1，修改P1的allocation及Need数据，还有系统的Available数据。
P1的allocation变为(1，4，2，0)，P1的Need变为(0，3，3，0)，系统的Available变为(1，1，0，0)。
③利用安全性算法检查此时系统是否安全。
Work Need Allocation W+A Finish
   A B C D A B C D A B C D A B C D
P0 1 1 0 0 0 0 0 0 0 0 1 2 1 1 1 2 True
P2 1 1 1 2 1 0 0 2 1 3 5 4 2 4 6 6 True
P1 2 4 6 6 0 3 3 0 1 4 2 0 3 8 8 6 True
P3 3 8 8 6 0 6 5 6 0 0 1 4 3 8 9 10 True
因为找到一个安全序列(P0，P2，P1，P3)，故系统处于安全状态，可以将P1请求的资源立该分配给P1。
```





### 3.

![image-20210113114904122](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113114904.png)





![image-20210113114930718](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113114930.png)







### 4.

![image-20210220151137202](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210220151144.png)





![image-20210113115748308](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113115748.png)



```
题目隐含要求是磁盘逻辑块号要从1开始
```



## 程序分析题目 （2题 20分）



### 1.(7分)

```
下列算法试图解决进程互斥问题

bool blocked[2];
enum{0,1} turn;

blocked[0]=blocked[1]=flase;
turn=0;



void P[int id]{
  blocked[id]=true;            (1)
  while(turn!=id){             (2)
      while(blocked[1-id]);    (3)
          turn=id;             (4)
}


/*  临界区 */;
blocked[id]=false;
/*  剩余部分  */;

}


假设进程调度先执行了id=0的语句，请重点结合 举例分析上面的算法会让两个进程同时进入临界区的运行顺序





答案:
上述P操作代码，先上锁后检查，
p[id=1].1   p[id=1].2  p[id=1].3    p[id=0].1 p[id=0].2 p[id=1].4




```









### 2.(往年卷 13分)





![image-20210113211242327](https://raw.githubusercontent.com/yusenyi123/pictures1/master/imgs/20210113211242.png)


















