# 王道易错题整理

## 第一章







## 第二章(进程管理)

### 2.1





### 2.2(处理机调度)

#### 1.( )有利于CPU繁忙型的作业，而不利于I/O繁忙型的作业。

A．时间片轮转调度算法
B．先来先服务调度算法
C．短作业(进程)优先算法
D．优先权调度算法

```
正确答案
B

答案解析 
先来先服务(FCFS)调度算法是一种最简单的调度算法，当在作业调度中采用该算法时，每次调度是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
FCFS调度算法比较有利于长作业，而不利于短作业。所谓CPU繁忙型的作业，是指该类作业需要大量的CPU时间进行计算，而很少请求I/O操作。I/O繁忙型的作业是指CPU处理时，需频繁的请求I/O操作。所以CPU繁忙型作业更接近于长作业。答案选择B选项。
```

#### 2.某系统正在执行三个进程P1、P2和P3,各进程的计算(CPU)时间和I/O时间比例如下表所示。为提高系统资源利用率,合理的进程优先级设置应为(  )。

| 进程 | 计算时间 | I/O时间 |
| ---- | -------- | ------- |
| P1   | 90%      | 10%     |
| P2   | 50%      | 50%     |
| P3   | 15%      | 85%     |

A．P1＞P2＞P3
B．P3＞P2＞P1
C．P2＞P1=P3
D．P1＞P2=P3

```
正确答案
B

答案解析
[解析] 本题考查考生对调度算法的实际应用。不同的调度算法具有不同属性，可能对某些进程有特殊偏好。例如短进程优先算法就会特别眷顾短进程，长进程就会被忽视。这与设计操作系统时需要保证系统的公平性相悖，所以，为了选择合适的算法，必须分析各个算法的属性。调度的基本准则包括：尽可能让昂贵的处理机处于繁忙中；单位时间内所完成进程的数量尽量多；要让周转时间尽可能地少；后备时间越短越好；等待时间越短越好；响应时间越短越好。本题中，由于进程的CPU时间和I/O时间不同，I/O越繁忙，表示其状态由执行到阻塞的变化越多，为此，公平起见，给予较高的优先级，同时也避免CPU繁忙的进程独占处理机。考察本题，调度的公平性是最重要的。若将P1的优先级设为最高，那么很有可能其会长期占用处理机，造成其他进程的饥饿，所以，从公平性考虑，需要均衡配置处理机的时间。
```



### 2.3(进程同步)

不懂点：可重入代码，管程



#### 1.在下列同步机制中，可以实现让权等待的是(**C**)

A.Peterson方法
B.swap指令
C.信号量方法
D.TestAndSet指令

```

硬件方法实现进程同步时不能实现让权等待，故B、D错误，Peterson算法满足有限等待但不满足让权等待，故A错误；记录型信号量由于引入阻塞机制，消除了不让权等待的情况，故C正确。

```







### 2.4(死锁)









## 第三章

### 3.1(内存管理概念)

#### 易错题

#### 1.在使用交换技术时，如果一个进程正在( )时，则不能交换出主存。

A．创建
B．I/O操作
C．处于临界段
D．死锁

```
正确答案
B

答案解析
进程正在进行I/O操作时不能换出主存，否则它的I/O数据区将被新换入的进程占用，导致错误。不过可以在操作系统中开辟I/O缓冲区，将数据从外设输入或将数据输出到外设的I/O活动在系统缓冲区中进行，这时在系统缓冲区与外设I/O时，进程交换不受限制。
```

### 2.下列关于页式存储正确的有( )。

Ⅰ．在页式存储管理中，若关闭TLB，则每当访问一条指令或存取一个操作数时都要访问2次内存
Ⅱ．页式存储管理不会产生内部碎片
Ⅲ．页式存储管理当中的页面是为用户所感知的
Ⅳ．页式存储方式可以采用静态重定位

A．Ⅰ、Ⅱ、Ⅳ
B．Ⅰ、Ⅳ
C．只有Ⅰ
D．全都正确

```
正确答案
C

答案解析
Ⅰ正确：关闭了TLB之后，每当访问一条指令或存取一个操作数时都要先访问页表(内存中)，得到物理地址后，再访问一次内存进行相应操作。Ⅱ错误：记住凡是分区固定的都会产生内部碎片，而无外部碎片。Ⅲ错误：页式存储管理对于用户是透明的。Ⅳ错误：静态重定位是在程序运行之前由装配程序完成的，分配必须要求全部连续存储空间，而页式存储将程序分成若干页，在内存中离散存放，不符合静态重定向的要求
```



#### 知识点

```
TLB:Translation Lookaside Buffer.
根据功能可以译为快表，直译可以翻译为旁路转换缓冲，也可以把它理解成页表缓冲。里面存放的是一些页表文件（虚拟地址到物理地址的转换表）。当处理 器要在主内存寻址时，不是直接在内存的物理地址里查找的，而是通过一组虚拟地址转换到主内存的物理地址，TLB就是负责将虚拟内存地址翻译成实际的物理内 存地址，而CPU寻址时会优先在TLB中进行寻址。处理器的性能就和寻址的命中率有很大的关系。



程序装入的三种方式(按照物理地址如何产生进行分类)
1.绝对装入
在编译时产生，也可以由程序员编程时直接赋予，只适合单道程序运行的情况


2.可重定位装入(又名静态重定位)
由操作系统中的装入程序在将需要运行的程序装入内存时产生去，使用该方式装入程序时必须给该程序分配他要求的全部内存空间，一旦分配完成，在运行期间不能在内存中移动，也不能再申请内存空间
只有固定内存分配，单一连续分配适合该装入方式


3.动态运行时装入(又名动态重定位)

```



```
内存扩充三种方式(不是对内存物理上的扩充，而是在逻辑上的扩充，可以节省物理内存)
1. 覆盖技术
覆盖技术是为了解决在单道程序运行环境下，内存无法装下一个进程的情况(覆盖技术要求内存的分配方式是单一连续分配 或 固定分区分配)
原理：将内存分为固定区和覆盖区，程序的活跃部分存放在固定区，其余按照调用关系，在需要调用时存放到覆盖区中


2. 交换技术
3.虚拟内存技术
```



### 3.2(虚拟内存管理)





#### 易错题



#### 知识点

```
传统存储管理分配方式（程序运行时，将程序全部装入内存）
根据是否为这个用户程序分配一个连续的内存空间，传统存储管理分配方式分为连续分配管理和离散分配管理
1.
2.
3.
4.
```

![image-20210219141044769](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210219141052.png)

## 第四章

### 4.1(文件系统基础)

#### 易错题





#### 知识点

```
文件的逻辑结构，指用户观点出发看到的文件的组织形式，逻辑结构是指在文件的内部，数据逻辑上是如何组织起来的
文件的物理结构是从实现逻辑结构上出发，在外存存储组织形式上如何实现文件的逻辑结构

这两个关系类似于，数据结构中 树，图，顺序表等这些都是在逻辑上的概念，在实际实现这种逻辑上的数据结构时，对于物理存储则有顺序存储，链式存储，这都是这些数据结构的物理结构

文件是数据的集合，按照文件中的数据在逻辑上是否有关系可分成
1.无结构文件(流式文件)

2.有结构文件 (记录式文件)
   2.1 顺序文件
   2.2 索引文件
   2.3 索引顺序文件

```



```
顺序访问：当要访问某一个文件的某一个逻辑块时，需要依次访问该逻辑块之前的逻辑块才能访问

直接访问(随机访问):当要访问某一个文件的某一个逻辑块时，不需要依次访问该逻辑块之前的逻辑块，可以找到需要访问的逻辑块
```



### 4.2(文件系统实现)





### 4.3(磁盘组织与管理)

#### 易错题



#### 知识点

```
物理地址对应存储设备盘面上的一块物理区域

物理地址在实际物理设备上如何进行标号?
物理地址按照（柱面号(磁道号),盘面号,扇区号）这样的组成结构从0开始标记

比如0号物理地址就位于第一块盘面的第一个盘面(一个盘片最多可以有上下两个盘面)最内圈的磁道中的一个扇区

为什么地址是按照（柱面号(磁道号),盘面号,扇区号）这样的形式而不是（盘面号,柱面号(磁道号),扇区号）这样的形式?
在按照物理地址读取盘片中数据时，磁道的切换是需要时间的，把磁道号放在高地址位置，可以减少读取数据时磁道切换的时间，只有一个文件过大时他跨磁道了才进行磁道切换读取

```







## 第五章









## 学习问题

```
1. 在动态分区存储管理方式中，为什么不能使用覆盖技术?
覆盖技术的诞生：
是因为在内存大小明确的情况下，当前内存无法存放进一个完整的进程，所以采用覆盖技术用户对程序进行修改，将程序分成若干段，在内存中划分固定区和覆盖区，固定区存放活跃的程序段，将需要调用的程序段放入覆盖区，其余段放在外存，在调用前，系统再将其调入覆盖区，替换覆盖区中原有的程序段

使用这种技术的逻辑顺序是这样的

明确的内存大小，但是该明确的内存大小不足以存放一个完整的进程->用户对程序进行修改

在动态分区存储管理中，逻辑顺序是这样的

在装入程序时，系统判断进程的所需内存->分配给进程需要的内存


动态分区存储管理和覆盖技术的因果关系不同，使用覆盖技术的前提必须知道要在哪一块大小明确的内存上对程序进行修改符合覆盖技术的要求
而动态分区存储管理时，系统并没有给出明确的内存大小，反倒是系统根据进程所需内存大小来进行内存的分配，当然不能使用覆盖技术



```

