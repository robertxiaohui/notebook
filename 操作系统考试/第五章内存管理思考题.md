# 第五章思考题

## 1.试述存储管理的基本功能

```
1.存储分配
2.地址映射
3.存储保护
4.存储共享
5.存储扩充
```



## 2.试述计算机系统中的存储器层次。为什么要配置层次式的存储器？

```
层次：(由下往上，访问速度越来越快)磁带，磁盘，主存储器，高速缓存，寄存器
原因：以便在容量大小，速度快慢，价格高低等诸多因素中取得平衡点，获得较好的性能/价格比
```



## 3.什么是逻辑地址、物理地址？简述不同编译、链接、装载与地址定位过程

```
逻辑地址（Logical Address） 是指由程序产生的与段相关的偏移地址部分。例如，在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在Intel实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制,Cpu不进行自动地址转换）；逻辑也就是在Intel 保护模式下程序执行代码段限长内的偏移地址（假定代码段、数据段如果完全一样）。应用程序员仅需与逻辑地址打交道，而分段和分页机制对您来说是完全透明的，仅由系统编程人员涉及。应用程序员虽然自己可以直接操作内存，那也只能在操作系统给你分配的内存段操作。

物理地址（Physical Address） 是指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址。如果启用了分页机制，那么线性地址会使用页目录和页表中的项变换成物理地址。如果没有启用分页机制，那么线性地址就直接成为物理地址了。

程序编译：源程序经过编译程序或汇编程序的处理生成目标模块（也成目标代码）


程序链接：

【1】静态链接：静态链接是在程序装载到内存和运行前，就已将他的所有目标模块及所需的库函数进行链接和装配成一个完整的可执行程序且此后不在拆分，静态方式使得链接过程和装载过程相对独立，链接程序和装载程序可独立设计，但不支持内存空间的中目标模块的单副本、不利于模块共享。

【2】动态链接：动态链接是指在程序装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一边链接，生成一个可执行程序。

【3】运行时链接：运行时链接是指将某些目标模块或库函数的链接推迟到执行时才进行。

程序装载

【1】绝对装载。装载模块中的指令地址始终与其内存中的地址相同，即在模块中出现的所有地址都是内存的绝对地址。

【2】可重定位装载。根据内存当时使用情况，决定将装载代码模块放入到内存的物理地址，模块内使用的地址都是相对地址。

【3】动态运行时装载。为了提高内存使用率。装入内存的程序可换出到磁盘上，适当时候再换入到内存中，对换前后程序在内存中的位置可能不同，即允许进程的内存映像在不同时候处于不同位置，此时模块内使用的地址必为相对地址。

程序定位：

【1】静态地址重定位。由装载程序实现装载代码模块的加载和地址转换，把他装入分配给进程的内存指定区域，其中所有逻辑地址修改成内存物理地址，称静态地址重定位。

【2】动态地址重定位。由装载程序实现装载代码模块的加载，把他装入分配给进程的内存指定区域，但对链接程序处理过的应用程序的逻辑地址则不做任何修改，程序内存气质地址被置入硬件专用寄存器--重定位寄存器。

【3】运行时链接地址重定位。对于静态和动态地址重定位装载方式而言，装载代码模块是由整个程序的所有目标模块及库函数目标模块经链接和整合构成的可执行程序，即在程序启东市指定已经完成了程序的链接过固定分区管理的缺点是什么?
```

## 4.何谓地址转换（重定位）？哪些方法可以实现地址转换

```
可执行的程序逻辑地址转换（绑定）为物理地址的过程称为地址转换。 实现方法：静态地址重定位，动态地址重定位，运行时链接地址重定位。 
```



## 5.分区存储管理中常用哪些分配策略？比较它们的优缺点。

```
答：1、固定分区存储管理  其基本思想是将内存划分成若干固定大小的分区每个分区中最多只能装入一个作业。当作业申请内存时系统按一定的算法为其选择一个适当的分区并装入内存运行。由于分区大小是事先固定的因而可容纳作业的大小受到限制而且当用户作业的地址空间小于分区的存储空间时造成存储空间浪费。 
2、可变分区存储管理  可变分区存储管理不是预先将内存划分分区而是在作业装入内存时建立分区使分区的大小正好与作业要求的存储空间相等。这种处理方式使内存分配有较大的灵活性也提高了内存利用率。但是随着对内存不断地分配、释放操作会引起存储碎片的产生。 

```

## 6.什么是移动技术？在什么情况下采用这种技术？

```
答：移动技术是：把主存中的实际存储单元称为物理地址（绝对地址），物理地址的总体相应构成了用户程序实际运行的物理地址空间。在未分配表中找不到一个足够大的空闲区来装入作业时采用移动技术
```

## 7.若采用表格方式管理可变分区,试绘制分配和释放一个存储区的算法流程图(无答案)

```

```



## 8.什么是存储保护?在分区存储管理中如何实现分区的保护?

```
存储保护：防止地址越界和控制正确存储
地址越界保护：进程运行时所产生的所以主存访问地址都应进行检査，确保进程仅访问自己的主存区
信息存取保护：进程在访问分配给自己的主存区时，要对访问权限进行检查，如允许读，写执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏主存信息。
```

## 9.什么是虚拟存储器?列举采用虚拟存储技术的必要性和可能性。

```
虚拟存储技术：在具有层次结构存储器的计算机系统中，自动实现部分装入和部分替换功能，能存逻辑上为用户提供一个比物理内存容量大得多的、可寻址的“内存储器”。 必要性：可用较小的内存空间执行较大的程序，能容纳更多的并发执行程序。 可能性：基于程序的局部性原理。
```



## 10.试述请求分页虚存管理的实现原理。

```
请求分页虚拟存储管理是将进程信息的副本存放在辅助存储器中，当它被调度投入运行时，并不把程序和数据全部装入主存，仅装入当前使用的页面，进程执行过程中访问到不在主存的页面时，再把所需信息动态地装入
```

## 11.试述请求分段虚存管理的实现原理。

```
请求分段虚存管理是将进程信息副本存放在外存中，当它被调度投入运行时，程序和数据没有全部装入内存，仅装入当前使用段，进程执行过程中访问到不在内存的段时候，再有系统自动调入。 
```



## 12.分页虚拟存储管理中有哪几种常见的页面淘汰算法

```
最佳页面替换算法、先进先出页面替换算法、最近最少使用页面替换算法、第二次机会页面替换算法、时钟页面替换算法。
```



## 13.试比较分页式虚存管理和分段式虚存管理。

![image-20210307110521146](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210307110528.png)

## 14.试述几种存储保护方法，这些方法各适用于何种场合?

```
方法：

    1.在CPU中设置一对下限寄存器和上限寄存器,存放用户作业在主存中的下限和上限地址
    2.可将一个寄存器作为基址寄存器，另一寄存器作为限长寄存器（指示存储区长度）

每当CPU要访问主存，硬件自动将被访问的主存地址与界限寄存器的内容进行比较，以判断是否越界如果未越界，则按此地址访问主存，否则将产生程序中断——越界中断（存储保护中断）。


```

![image-20210307113903919](https://raw.githubusercontent.com/yusenyi123/pictures2/master/imgs/20210307113904.png)





## 15.试述存储管理中的碎片。列出各种存储管理方法中可能产生何种碎片

```
所谓“内部碎片”，是指系统已经分配给用户使用、用户自己没有用到的那部分存储空间；所谓“外部碎片”，是指系统无法把它分配出去供用户使用的那部分存储空间。对于教材而言，单一连续区存储管理、固定分区存储管理、分页式存储管理和请求页式存储管理都会出现内部碎片。只是前两种存储管理造成的内部碎片比较大，浪费较为严重；后两种页式存储管理，平均来说每个作业都会出现半页的内部碎片。教材中，只有可变分区存储管理会产生外部碎片。
```



## 16.采用可变分区方式进行存储管理,假设允许用户运行时动态申请/归还内存资源,这时系统可能因竞争内存资源而产生死锁吗?如果否,试说明之,如果是,试设计一种解决死锁的方案(无答案)







## 17.试述分页式存储管理中决定页面大小的主要因素。

```
主要因素：页表所占主存空间，主存利用率，读写页面所需时间(详细P274)
```



## 18.试述实现虚拟存储器的基本原理。

```
不必装入全部信息，仅将当前使用部分装入主存，其余部分存放在磁盘中，待使用时由系统自动将其装进来，这就是虚拟存储器管理技术的基本思路。部分装入+部分替换
```

## 19.采用页式存储管理的存储器是否就是虚拟存储器，为什么？实现虚拟存储器必须哪些软硬件支撑？(无答案)





## 20.如果主存中的某页正在与外部设备交换信息，那么，当发生缺页中断时，可以将这一页淘汰吗？为什么？出现这种情况时，你能提出怎样的处理方法？

```
不可以。在使用虚拟页式存储管理时需要在页表中增加一些内容，得到页表内容为：页号、驻留位、内存块号、外存地址、访问位、修改位。其中驻留位，又称中断位，表示该页是在内存还是在外存；访问位表示该页在内存期间是否被访问过，称为R位；修改为表示该页在内存中是否被修改过，称为M位。访问位与修改位可以用来决定置换哪个页面，具体由页面算法来决定。
```



## 21.为什么在页式存储器中实现程序共享时，必须对共享程序给出相同的页号？

```
实现程序共享时，由于页式存储结构要求逻辑地址空间是连续的，共享程序若含有转移指令，这些转移指令的转移地址是确定的，所以在程序运行前共享程序的页号必须是确定的。例如：假定有一个共享程序EDIT，其中含有转移指令，转移指令中的转移地址必须指出页号和偏移，如果是转向本页，则页号与本页页号相同。现若有两个作业共享这个EDIT程序，假定一个作业定义它的页号为3，另一个作业定义它的页号为5，而在主存中只有一个EDIT程序，它要为两个作业以同样的方式服务，这个EDIT程序一定是可再人的（纯代码的），于是转移指令中的页号是不能按作业的要求随机地改成3或5。所以，对共享程序必须规定一个统一的页号。
```





## 22.在段式存储器中实现程序共享时，共享段的段号是否一定要相同？为什么？

```
答：不用。几道作业共享的例行程序可放在一个段中，只要让各道作业的共享部分
有相同的基址/限长值就行了，共享的段号不一定相同。
```



## 23.试述段页存储器的主要优缺点。

```
答：段页式存储分配方式既照顾到了用户共享和使用方便的需求，又考虑到了主存的利用率，提高了系统的性能。 段页式存储分配方式的空间浪费要比页式管理的多。作业各段的最后一页都有可能浪费一部分空间。另外段表和页表占用的空间都比页式和段式的多，这样就增加了系统开销。
```



## 24.试述虚拟管理与实存管理之间的主要区别。

```
根本区别就在于，虚拟管理允许部分装入和部分对换，而实存管理不允许这样做。所谓"部分装入"，指的是一道应用程序不是全部装入存以后才开始执行而是只装入其中一部分，甚至一点都不装入就开始运行，然后在运行的构成中根据需要逐步的装入其余部分；"部分对换"，指的是当存已满而又有新的将"部分"需要装入时，要把已在存的某一"部分"换出去，以腾出空间存放新来者。部分装入和部分对换的结果是可以用较小的存运行较大的程序。实存管理则不同，它所要求的是整体装入。
```

## 25.试述虚拟存储器与下列技术的关系:(1)多道程序设计;(2)程序地址重定位！！(没答案)





## 26.什么是“抖动”?试给出抖动的例子。

```
当存储管理方式采用页式存储时，缓存（这里我们必须要知道缓存的大小一般比较小，不可能容纳所有需要使用的页）中的页需要可能被替换，这种替换是遵守一定法则的，不是随便来的。下次要使用的页在这回却回替换出去了，这样的现象就称为抖动。抖动对系统效率的影响是很大的。一般来说，对于一个循环程序，如果分配给它的页面数小于程序所需要的页面数时，有可能发生抖动
```

## 27.在可变分区存储管理中回收一个分区时有多种不同的邻接情况，试讨论各种情况的处理方法

```
有四种：上邻，下邻，上下相邻，上下不相邻。 （1）回收分区的上邻分区是空闲的，需要将两个相邻的空闲区合并成一个更大的空闲区，然后修改空闲区表。 （2）回收分区的下邻分区是空闲的，需要将两个相邻的空闲区合并成一个更大的空闲区，然后修改空闲区表。 （3）回收分区的上、下邻分区都是空闲的，需要将三个空闲区合并成一个更大的空闲区，然后修改空闲区表、 （4）回收分区的上、下邻分区都不是空闲的，则直接将空闲区记录在空闲区表中
```

## 28.在请求分页存储管理中，若把进程的页框数增加一 倍,则缺页异常次数会减少会减少至少一半吗？为什么？

```
不一定是一半，这还得取决于操作系统内核的相关结构以及实际运行情况。因为系统中，缺页中断次数和页面大小有些关系，但并不只取决于页面大小，还跟系统总内存总量等很多因素有关，当系统内存不足时，会发生页面交换，此时也会产生很多次缺页中断，但与页面大小就没有太大关系了
```

## 29.试讨论虚拟存储器容量与地址址总线宽度、内存容量及外存容量之间的关系。

```
虚拟存储器的最大容量由主存和辅存的容量之和确定。   
虚拟存储器的实际容量由指令中表示地址的字长决定，也就是计算机的地址结构决定的。
```

## 30.分页式存储管理中，决定页面大小的主要因素是什么？试分析大页面与小页面各自的优点。

```
（1）页面大小的设置主要因素是与系统的硬件有关。 （2）如果页面较小，虚存的页面数就增加，页表也随着扩大，占用的空间多，但碎片小，浪费少；如果页面较大，可以减少页表所耗费的存储空间，有利于提高I/O的效率，但部碎片大，浪费多。
```



## 31.试述缺页异常与一般中断之间的区别。

```
1、范围不同

一般中断只需要保护现场，然后就直接跳到需及时处理的地方。

缺页中断除了保护现场之外，还要判断内存中是否有足够的空间存储所需的页或段，然后再把所需页调进来再使用。

2、结果不同

一般中断在处理完之后返回时，执行下一条指令。

缺页中断返回时，执行产生中断的那一条指令。

3、次数不同

在指令执行期间产生和处理缺页中断信号，一条指令在执行期间，可能产生多次缺页中断。

一般中断只产生一次，发生中断指令后转入相应处理程序进行处理，恢复被中断程序现场。


程序在执行时，当访问的页面不在内存时，便产生缺页中断，请求操作系统将所缺页调入内存。中断处理程序将把控制转向缺页中断子程序。然后系统执行此子程序，把所缺页面装入主存中。接着处理器将重新执行缺页时打断的指令。缺页中断是一种特殊的中断，也就是说，缺页中断同样需要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU环境等几个步骤，但与一般的中断相比，它又具有以下不同点： 1. 一般中断是一条指令完成后中断，而缺页中断是在一条指令执行时中断。通常，CPU都是在一条指令执行完之后，才检查是否有中断请求到达。如果有，便去响应中断，否则，继续执行下一条指令。然而，缺页中断则是在指令执行期间，发现所访问的指令或数据不在内存时所产生和处理的。 2. 一条指令执行时可能产生多个缺页中断。如指令可能访问多个内存地址，这些地址在不同的页中。
```



## 32.试述虚拟存储器与外存储器之间的关系。

```
虚拟内存是计算机系统内存管理的一种技术.它使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间),而实际上,它通常是被分隔成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换
```



## 33.在请求分页虚拟存储的替换算法中，对于任何给定的驻留集尺寸，在什么引用串情况下FIFO和LRU替换算法一样(即所替换的页面和缺页中断率一样)？举例说明

```
由于驻留集大小任意，现要求两种算法的替换页面和缺页情况完全一样，就意味着要求FIFO与LRU的置换选择一致。FIFO是替换最早进入主存的页面，LRU是替换上次访问以来最久未被访问的页面，这两个页面一致。就是说，最先进入主存的页面在此次缺页之前不能再被访问，这样该页面也就同时是最久未被访问的页面。
例如，合法驻留集大小为4时，对访问串1、2、3、4、1、2、5，当5号页面调入主存时，应在1、2、3、4页中选择一个替换，FIFO选择1，LRU选择3。原因在于1号页面虽然最先进入主存，但由于其进入主存后又被再次访问，所以它不是最久未被访问页面。如果去掉对1号页面的第二次访问，则FIFO与LRU的替换选择就相同。同理，当5号页面调入主存后，若再访问新的6号页面，则2号页面会遇到同样的问题。所以依此类推，访问串中的所有页面号都应不同，但注意到，连续访问相同页面时不影响后面的替换选择，所以对访问串的要求是：
不连续的页面号均不相同。
```



## 34.解决大作业和小内存之间的矛盾有哪些途径?简述其实现思想。

```
覆盖和对换技术是解决大作业和小内存矛盾的两种存储管理技术，是多道程序环境下用扩充内存的两种方法，其实质是对内存进行逻辑扩充。 覆盖主要用于早期的操作系统，而对换在现代操作系 统中仍具有较强的生命力。
　　1. 覆盖技术： 一个程序并不需要一开始就把它的全部信息装入内存再开始执行； 把程序划分成若干个功能上相对独立的程序段，并按 照程序的逻辑结构，让那些不会同时执行的程序段共 享同一块内存区。 这些程序段都被保存在外存(如磁盘)中，当有关程序 段的先头程序段执行结束后，再把后续程序段调入内 存中覆盖前面的程序段。
　　2. 对换技术： 所谓“对换”(或称交换)，是指把内存中暂不能运行的进 程，或暂时不用的程序和数据换出到外存上，以便腾出足 够的内存空间，把已具备运行条件的进程或进程所需要的 程序和数据，换入内存。对换是提高内存利用率的有效措 施。 如果对换是以整个进程为单位，称之为“进程对换”。若 对换以“页”或“段”为单位进行，则分别称之为“页面 对换”或“分段对换”。 为了实现进程对换，系统必须实现3个方面的功能：对换 空间的管理、进程的换出以及进程的换入。
```

## 35.在请求分页虚拟存储系统中,若已测得时间利用率为:CPU 20%、分页磁盘97.7%,其他部分设备50%。试问哪些措施可以改善CPU利用率?

```
CPU利用率是指系统整个运行时间里CPU有多少时间是真正用于程序的运算。由于磁盘的利用率已达到97.7%，说明磁盘空间紧而影响CPU利用率，因此更换大容量磁盘可以提高CPU利用率。慢速外设往往同快速CPU不匹配，因此提高I/O设备的速度也可以改善CPU的效率。此外，在存中适当增加进程数，可使CPU空闲时间减少，也可以在一定程度上提高CPU的利用率。 
```

## 36.在请求分页虚拟存储系统中，分析下列程序设计风格对系统性能所产生的影响:(1)迭代法;(2)递归法;(3)常用goto语句;(4)转子程序;(5)动态数组。(无答案)